--------------------[11.09.2019]-------------------------
---------------------------------------------------------
             a < b :
отношение     / нерефлексивноссть !(a < b)
(частичного  <| несимметричность (a < b) -> !(b < a)
порядка)      \ транзитивность (a < b) & (b < c) -> a < c

Для любых a и b:
   ._
   |  a > b
   |  a = b
   |_ a < b

   a = a + b
   b = a - b
   a = a - b
   если a = b то ошибка

-------------|Сортировка выбором|-------------
  * минумум или максимум
  @Максимум (минимум аналогично)
    SelectionSort(a):
        for i = size(a) - 1 to 0:
            x = findIndexOfMaxElement(a)
            swap(a[i], a[x])
  @Минимум
    selection_sort(int s[], int n)
    {
        int i, j, min;
        for (i = 0; i < n; i++) {
            min = i;
            for (j = i + 1; j < n; j++)
                if (s[j] < s[min]) min = j;
            swap(&s[i], &s[min]);
        }
    }
  * Время работы
      n + n - 1 + n - 2 + n - 3 + ... + 1 =
        n*(n + 1)    
      = --------- ~= O(n^2); O ~ n^2
            2
----------------------------------------------
-------------|Сортировка вставками|-----------
    Префикс уже отсортирован -> переход
        на префикс длины + 1
    1 3 5 7 9 4
    1 3 5 7 4 9
    ...
    1 3 4 5 7 9
    insertionSort(a):
        for i = 0 to size(a):
            j = i
            while (j > 0) and (a[j - 1] > a[j]):
                swap(a[j - 1], a[j])
                j = j - 1
  * Время работы
      0 + 1 + 2 + ... + n - 1 =
        n*(n - 1)
      = ---------; O ~ n^2; O(n^2)
            2
----------------------------------------------  
---------------------------------------------------------
------------|Сортировка пузырьком|------------
    2  3  9  5  6  6
    2  3  5  9  6  6
    2  3  5  6  9  6
    2  3  5  6  6  9

    bubble_sort(int s[], int n)
    {
        int i, j;
        for (i = 0; i < n; i++)
            for (j = 0; j < i; j++)
                if (s[j] > s[i])
                    swap(&s[i], &s[j]);
    }

    def bubble_sort(a: list, n: int):
        changed = False                             # optimization
        for i in range(n - 1, 0, -1):
            for j in range(i):
                if a[j] > a[j + 1]:
                    a[j], a[j + 1] = a[j + 1], a[j]
                    changed = True                  # optimization
            if not changed:                         # optimization
                break                               # optimization


    Время работы O(n^2)

    1  3  5  8  9  2
    1  3  5  8  2  9
    1  3  5  2  8  9
    1  3  2  5  8  9
    1  2  3  5  8  9

    Можно делать проходы по очереди вправо - влево:
----------------------------------------------
------------|Шейкерная Сортировка|------------
----------------------------------------------
    def bubble_sort(a: list, n: int):
        changed = False
        for i in range(n - 1, 0, -1):
            if i % 2:
                for j in range(i):
                    if a[j] > a[j + 1]:
                        a[j], a[j + 1] = a[j + 1], a[j]
                        changed = True
            else:
                for j in range(i - 1, 0, -1):
                    if a[j] > a[j + 1]:
                        a[j], a[j + 1] = a[j + 1], a[j]
                        changed = True
            if not changed:
                break
    Сложность: O(n^2)
----------------------------------------------
---------------|Число инверсий|---------------
----------------------------------------------
    Инвресия - такая пара индексов что
       _/ i < j
        \ a[i] > a[j]    

    Число инверсий в массиве
        тут ..96..73..4
        после 1 свопа кол-во инверсий
            уменьшается на 1
    Изначально Io инверсий
    Необходимое кол-во свопов хотя бы Io
    У с. выбором своп дальних элементов.
    Своп соседних:
    Для:
      * с. вставками
      * с. пузырьком
      * с. шейкером
          2
    Io = C  = n(n - 1) / 2    
          n
 ************************  
 *  Средний случай:
     
    ^   
    |                .---. В среднем
    |               /. . .\
    |_______________\_____/______________.______>
    .                  .                 .
    0               n(n-1)/4          n(n-1)/2
       ^                              \
      /                                \
     /                                  v

Зафиксируем пару объектов.

----------------------------------------------------------------
        Сортировки использующие св-ва сортруемых элементов
----------------------------------------------------------------
   1 0 1 0 0 1 0 1 0 1 0 0 1 0 1 1 0 1 1 0 0 1

   Сортировка подсчетом

    counting_sort(item_type s[], int n, int maxv)
    {
        item_type *c = calloc(maxv, sizeof(item_type));
        int i, j, b = 0;
        for (i = 0; i < maxv; i++)
           c[i] = 0;
        for (i = 0; i < n; i++)
           c[s[i]]++;
        for (j = 0; j < maxv; j++)
            for (i = 0; i < c[j]; i++) {
                s[b] = j;
                b++;
            }
        free(c);
    }











   ...X...A...B...Y...

   ...X...B...A...Y...
   Вклад каждой пары в общее кол-во иверсий: 0.5
   каждая пара +0 или +1 инверсия в вероятностью 0.5
   Ожидаемое число инвкерсий:
       n (n-1)    1    n (n-1)
       ------- * --- = -------
          2       2       4
----------------------------------------------
Устойчивость сортировок
    Определение
        сорт. устойчива если всегда сохраняет 
        относительный порядок равных элементов

   2  3  9  5  6` 6


   9 ...  9` ... 9`` 7` 7
     ...  7 7` 9 9` 9``
   Сортровка выбором неустойчива
   Остальные, очевидно, устойчиво.
   Только при > но не >=



----------------------------------------------
----------- Быстрая сортировка ---------------
----------------------------------------------
  Разделяй и властвуй
  2  3  9  5  6  6  3  0
           ^
           |
        разделительный элемент pivot

  1) элемент на центральной позиции
    <pivot        =pivot       >pivot
    2 3 3 0          5          9 6 6 
  рекурсивно     рекурсивно   рекурсивно  |если длина >= 2 
    0 2 3 3   -      5     -    6 6 9
 
  def qsort(a: list):
      if (len(a) < 2):
          return a[:]
      pivot = a[len(a) // 2]
      small = [x for x in a if x <  pivot]   # \
      equal = [x for x in a if x == pivot]   #  |> 3n
      large = [x for x in a if x >  pivot]   # /
      return qsort(small) + equal + qsort(large)

  ------ max ------
  
  ------max2-----max|
  -----------max2|

  самый худший случай:
  1 2 3 4 5 6 ... (n - 1) n (n - 1) (n - 2) ... 3 2 1
  n + (n - 1) + (n - 2) + ... + 1 = O(n^2)

   самый лучший пивот - случайный
   для такого (случайного): 
      нет самого худшего (только если хороший генератор)
      в среднем n*log(n)

  ----- ------------------------
  разделитель хороший - оба куска длиной меньше 3n/4
  ------- --------------- -------
    1/4         1/2         1/4
  *******                 *******
  * плохие пивоты

   длина наибольшего куска массива: вероятность перехода из n в x <= 3n/4 - 50%

  n -> 3n/4 -> (3n/4)^2 -> (3n/4)^3 ->    if (3n/4)^i <= 1 then break

  n * (3/4)^i = 1
  n = (4/3)^i
  i = log (n)
        4/3
  -------------------
  ----- - -----------
  - - -   ----- - ---
            -- ...
   w = log(n)
   h = n
------------------------------------------------------------------------------------
------------------------------ Сортировка слиянием ---------------------------------
------------------------------------------------------------------------------------

    1)  Слияние отсортированных массивов
        n   m
      ----  ----
        n + m
       --------
       O(n + m) = O(n)

    def merge(a: list, b: list):
         c = []
         i = 0
         j = 0
         n = len(a)
         m = len(b)
         while i < n or j < m:
             if ((j == m) or (a[i] <= b[j])):
                 c.append(a[i])
                 i += 1
             else:
                 c.append(b[j])
                 j += 1
         return c

    def merge_sort(a: list):
        if len(a) < 2:
            return a[:]
        return merge(
            merge_sort(a[:len(a) // 2]), 
            merge_sort(a[len(a) // 2:]))

    Время работы
        n = 2^k   если не т то незначительно
        ------- -------  ...
        --- --- --- ---  2n * 1/2 = n
        - - - - - - - -  n

        Всего ~ k + 1 уровней ~= log(n)
                                    2

        O = O(n * log(n))


    Подсчёт числа инверсий:
         ________
        |        |
     -- 9 *==* | 7 *==*
      a inv       b inv
           
             __________
            |          |
    1 3   8 9    | 2 5 7 7 7
        7 ~~~
    
    когда берем правый элемент то
    ивн += длина оставшегося куска
        
 Устойчив


---------------------------------------------------
              Сортровка подсчетом
---------------------------------------------------

    counting_sort(item_type s[], int n, int maxv)
    {
        item_type *c = calloc(maxv, sizeof(item_type));
        int i, j, b = 0;
        for (i = 0; i < maxv; i++)
            c[i] = 0;
        for (i = 0; i < n; i++)
            c[s[i]]++;
        for (j = 0; j < maxv; j++)
            for (i = 0; i < c[j]; i++) {
                s[b] = j;
                b++;
            }
        free(c); 
    }

    Массив кумулятивных сумм для массива count

    Устойчива

    Время работы

    default     6 1 3 0 5 0 1
    count       2 2 0 1 0 1 1 0 0 0
    position    2 4 4 5 5 6 7 7 7 7 

    n, k
    но если от -9 до 9 то ...
    надо  maxv = maxv - minv
    O(k + n)

-------------------------------------------------
Рекурсивный перебор

    уравновесить две чаши весов

    Задача 1182

    def search(a, diff, left=[], right=[]):
        if diff == 0:
            print(*left) if left else print(0)
            print(*right)
            exit(0)
        if not a:
            return
        search(a[1:], diff, left, right)
        search(a[1:], diff + a[0], left + [a[0]], right)
        search(a[1:], diff - a[0], left, right + [a[0]])

    w = int(input())
    n = int(input())
    a = list(map(int, input().split()))
    search(a, w)
    print(-1)

