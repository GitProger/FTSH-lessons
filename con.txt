#INCLUDE CONTEXT.TXT

Корзинная сортировка
 Busket Sort

 Данные: равномерно распределенные вещественные числа [0; 1)
   сигма - среднее квад. двух границ(y), характеризует насколько "колокольчик" "растянут"

   ^ y
   |
   |           .''.  .sg.
   |          /    \ :  :
   |        .'      ':  :
   |  __..-"          "-:.__
 --0--------------------------> x
   |

 n - длина массива
 поделим отрезок на n одинаковых корзин
 [0; 1/n) [1/n; 2/n) ... [(n-1)/n; 1)
 x - число, номер его корзины int(x * n)

 --- Листинг -----------------------------
   def busket_sort(a: list, n: int):
       bus = [[] for _ in range(n)]
       for x in a:
           b = int(x * m)
           bus[b].append(x)
       res = []
       for i in range(n):
           res += sorted(bus[i])
       return res
 -----------------------------------------

  Если не равномерно распределены числа, то работа - работа sorted (или любой другой сортировки)

 Сложность:
    n чисел раскиданы по корзинам
    запустим сортировку пузырьком без оптимизации на каждой группе
    m(m - 1) / 2
    C{m, 2}
    каждая пара чисел в одной корзине ==> 1 операция
    теперь оценить мат. ожидание кол-ва таких пар
    сумму этих велечин
    
    оценить кол-во пар в каждой корзине (1 пара - такт)
    Время: Итого кол-во пар попавших в одну корзину =
    = (кол-во пар чисел) * (на вероятность попасть пары в одну корзину)
    всего n(n - 1) / 2 пар чисел

    для каждой пары с какой веротностью они попадают в корзину: 1/n

    всего n^2 вариантов расположения из них в одну корзину - n вариантов
    итого n

    O' = (n(n - 1) / 2) * (1 / n) = (n - 1) / 2 ~= n
    O(n)


   ^ число людей
   |
   |
   |
   |                         доля чисел в этом диапазоне 1 / n - Квантель
   |                      .-.: 
   |                     /|||\
   |                __.-'|||||'-.__
 --0------|------|------|------|-----------------> рост
   |            100    150    200
   |
     n чисел

=================================================================================
==-----------------------------------------------------------------------------==
==----------------  Введение в методы глобальной оптимизации  -----------------==
==-----------------------------------------------------------------------------==
=================================================================================


 ^
 |
 |                                  
 |                           .......'''''
 |\               .----''''''
 | \       .-.   /
 |  \     /   \ /
 |   \   /     '
 |    '-'      - local min  
 |     - global min
 |
-|--------------------------------------->
 |

   find local min's with ternar search and choose the global minimun


 ^  
 |
 |                                   
 |
 |
 |
 |
 |---------. .--------- ---------------
 |         |/          .
 |
 |
-|--------------------------------------->
 |

 ternar search doent work here, only 'for'

  Пример лотерея:

 ^ win
 |
 |                                   
 |
 |
 |                            .
 |   .
 |            
 |           .
 |--- ------- ---------------- -------
-|---------------------------------------> id
 |

 Монотонные ф-ии
 Битонные ф-ии из 2 мон. ф-ий


   ___   .--''''-
  /|_|| | БИТОН /_.
  |   \_\__/   \
  '(O) ---- (O)


 Тернарный поиск

 ^  
 |
 |                                   
 |
 |-.              .-
 |  |.         .-'   
 |  | \       /|     
 |  |  -     - |
 |  |   '-.-'  |    
 |  |          |
 | low        high
 |
-|--------------------------------------->
 |


известно, что:  min Е [low, high]

 ./  a = low + (high - low) / 3   = 2/3 * low + 1/3 * high
 '\  b = high - (high - low) / 3  = ...

base:
 if f[a] < f[b]
    min E [low, b]

 if f[a] > f[b]
     min E [a, high] 

 if f[a] == f[b]
     min E [a, b]    

 eps = 10e-9
 while high - low > eps
    ...base...
 ans = (low + high) / 2

 Каждая итерация: interval *= 2/3
 
 Другая версия (Фиббоначиев поиск):
  |----1----|--x--|----1----|
  |--1--|-x-|--1--|
 Сохранять отношение
 x^2 - x = 1
 / x^2 - x - 1 = 0
 \ x < 1
 x = (sqrt(5) - 1)/2 = phi^- 1

 за 2 итерации interval *= phi^-1
 ! Факт: отношение чисел фиббоначи с увеличением номеров стремится к фи



 ^  
 |
 |                                   
 |         a    b
 |         .----.
 |\        |    |        /\/\
 | \       |   .|       /    \
 |  \     .|  / \     _/
 |   \   / \ /   \_.-'
 |    '-'   '
 |
-|--------------------------------------->
 |

здесь терн. поиск не работает
n-арный поиск, разбить на n частей
low +- 100; high +- 100
и рекурсивно для каждого подинтервала

-------------------------------------------------------------------------------
                   однозвязные и двусвязные списки
-------------------------------------------------------------------------------
from collections import deque

2 3 9 5 6 6


head = [5, first6]
first6 = [6, last6]
last6 = [6, None]

empty = None


head == [5, [6, [6, None]]]


def length(node):
    if node:
        return 1 + length(node[1])
    return 0

def sumn(node):
    if node:
        return node[0] + length(node[1])
    return 0

def elementAt(node, index):
    if not node:
        return None
    if not index:
        return node[0]
    return elementAt(node[1], index - 1)

def delete(node): #deletes next el after node
    node[1] = node[1][1]

def insert(node, x):
    node[1] = [x, node[1]]

--------------------------------------------------------
                  Двусвязные списки
--------------------------------------------------------

      v  next  prev      
el = [5, None, None]
 _________________________________________
 |                                       |
 |             5      6      6    None   |
 |   None<-----|<-----|<-----|<----|<----|
 ----None      |----->|----->|---->|-.
      ^______________________________|

def length(node)
    ...

def elementAt(node, n):
    ...

def delete(node): #deletes THIS node
    node[2][1] = node[1]
    node[1][2] = node[2]

def insert(node, x):
    a = [x, node[1], node]
    node[1] = a
    node[1][1][2] = a

### --- Кусок в тетрадке (Полиномиальные хэши, Алг. Кнута-Морриса-Пратта, Регэкспы) --- ###

############################################################################################
#                                                                                          #
#                       K   K     OOO     TTTTT    L       II   NN   N                     #
#                       K  K     O   O      T      L       II   N N  N                     #
#                       KKK      O   O      T      L       II   N  N N                     #
#                       K  K     O   O      T      L       II   N   NN                     #
#                       K   K     OOO       T      LLLLL   II   N    N                     #
#                                                                                          #
############################################################################################
Спасибо Дворкину:)
############################################################################################

* Kotlin интероперабельный с Java

|Kotlin -- "очень кроссплатформенный"
|-> JVM - Java Virtual Machine
|-> JS - JavaScript
|-> Kotlin Native

fun main() { println("Hello world!") }

------------------------  Базовые типы данных
Целочисленные типы:
    - Byte   1 байт
    - Short  2 байта
    ! Int    4 байта
    - Long   8 байт
    * BigInteger
Вещественные:
    - Float    4 байт
    ! Double   8 байт
    * BigDecimal
    ~ Символьные вычисления
Логические типы:
    ! Boolean (true / false)    1 байт
    * BitSet
Строковые типы:
    ! Char      2 байта
    ! String
Знаковые целочисленные типы:
    | Беззнаковый тип:
    |    //unsigned byte
       |Signed
       |____|____|____|____|____|____|____|____|
       |-128|  64|  32|  16|   8|   4|   2|   1|
       
 ___________________________________________________
 | Хранение вещественных чисел в памяти компьютера |
   Standart: IEEE 754      [i triple e]
   |-> decimal 32
   |   decimal 64
   |   decimal 128
   |-> binary 16
   |   binary 32    float
   |   binary 64    double  _____.
   |   binary 128                 |
   |   binary 256                 |
                                  |
                          _______/
                         /
                        V
=====-------------  DOUBLE:  -------------=====
                  [Binary 64]

 s            e                       m
|__$__|__|_......._|__|__$__|__|__|__|__|_..._|__|
   $                     $                       |
 ^ $ 11 bits (exponent)  $ 52 bits (mantissa)    |
 |
  \ bit 1 -> {0: "+", 1: "-"}


Научная нотация
+- ________ * 10 ^ экспонента (целая)
   мантисса ( полуинтервал [1, 10) )
   
Real Binary:

Но 0 не поддерживается

Сравнение: снача сравнение экспонент, если они равны то сравнение уже мантисс
e ∈ [0, 2047] /\ N

                m (52b)
(-1 ^ s) * 1. .......... * 2 ^ (e - 1023)    ---- нормальные числа в двоичной нотации

1.5 = (-1 ^ 0) * ( (((1))) + 2 ^ -1) * 2 ^ 0
-7 = -1.75 * 2 ^ 2 -->  1_00100000000_  (((1.)))1100000...     

e ∈ [1, 2046]             -- нормальные числа
e = 0                     -- субнормальные
e = 2047                  -- Nan & +-Infinity

   Субнормальные числа:
+1 ...  * 2 ^ 0

0               1 ||||||||||||||  2
                   2 ^ 52 номера (арифметическая прогрессия (шаг 2 ^ -52))
              
   (-1) ^ s * 2 ^ -1022 * 0. ...
                 

m = 0   -> inf (+-)
m =/= 0 -> NaN


min normal: 2 ^ -1074
max normal: 2 ^ 1075


if (cond) {
    ...
    ret;
} else if (cond2) {
    ...
    ret2;
} else {
    ...
    ret3;
}

for (val in coll) {
    
}

val n = 10
for (x in n - 3 .. n + 5) { println(x) }
for (x in 1..10) { prinln(x) }

run {
    val x = 7
    println(x)
}


Ranges (IntRange)

for (x in 0 until 10)
for (x in 10 downTo 0)

for (x in 0 until 5 step 2) { ... }  // for (int x = 0; x < 5; x += 2) { ... }    for x in range(1, 5, 2):
for (x in 10 downTo 0 step 3) { ... }  // for (int x = 10; x >= 0; x -= 3) { ... }    for x in range(10, -1, -3):


cycle@for (...) {
    for (...) {
        if (...) {
            break@cycle
        }
    }
}

Функции:

fun name(Param: Type): RetType { // Default RetType = Unit [void]
    return ...
}

fun name(Param: Type) = return ...



Коллекции:

- Списки (Изменяемые и неизменяемые) (как списки и кортежи в питоне)

List        <--> tuple
MutableList <--> list

val a = listOf(2, 3, 9)
val b = listOf<Any>()

val a = mutableListOf(2, 3, 9)
val b = mutableListOf<Any>()

val x = a[i];
val first = a.first()
val last = a.last()
val size = a.size

"Умное создание списка" like [x for x in range(4, 5 * n - 1, 3)]
 List((5 * n - 1) / 3) { (it + 4) * 3 }

val a = List(100) { 0 }

Формально:
val b = List(length) {
    ...any code...
    returnValue
}

var x = 1.toBigInteger
val a = List(100) { 
    x *= 2.toBigInteger
    x
}


val a = List(100) { it } // it - position

repeat(100) { println(it) }

val a = List(100) { i ->  // now it is i
    println(i)
    i + 1
}

val tb = List(4) { i ->
    List(4) { j -> (i + 1) * (j + 1) }
}


a.take(7) // first 7 elements
a.takeLast(7) // last 7 elements

a.shuffled().take(7) // random 7 elements





