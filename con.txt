#INCLUDE CONTEXT.TXT

Корзинная сортировка
 Busket Sort

 Данные: равномерно распределенные вещественные числа [0; 1)
   сигма - среднее квад. двух границ(y), характеризует насколько "колокольчик" "растянут"

   ^ y
   |
   |           .''.  .sg.
   |          /    \ :  :
   |        .'      ':  :
   |  __..-"          "-:.__
 --0--------------------------> x
   |

 n - длина массива
 поделим отрезок на n одинаковых корзин
 [0; 1/n) [1/n; 2/n) ... [(n-1)/n; 1)
 x - число, номер его корзины int(x * n)

 --- Листинг -----------------------------
   def busket_sort(a: list, n: int):
       bus = [[] for _ in range(n)]
       for x in a:
           b = int(x * m)
           bus[b].append(x)
       res = []
       for i in range(n):
           res += sorted(bus[i])
       return res
 -----------------------------------------

  Если не равномерно распределены числа, то работа - работа sorted (или любой другой сортировки)

 Сложность:
    n чисел раскиданы по корзинам
    запустим сортировку пузырьком без оптимизации на каждой группе
    m(m - 1) / 2
    C{m, 2}
    каждая пара чисел в одной корзине ==> 1 операция
    теперь оценить мат. ожидание кол-ва таких пар
    сумму этих велечин
    
    оценить кол-во пар в каждой корзине (1 пара - такт)
    Время: Итого кол-во пар попавших в одну корзину =
    = (кол-во пар чисел) * (на вероятность попасть пары в одну корзину)
    всего n(n - 1) / 2 пар чисел

    для каждой пары с какой веротностью они попадают в корзину: 1/n

    всего n^2 вариантов расположения из них в одну корзину - n вариантов
    итого n

    O' = (n(n - 1) / 2) * (1 / n) = (n - 1) / 2 ~= n
    O(n)


   ^ число людей
   |
   |
   |
   |                         доля чисел в этом диапазоне 1 / n - Квантель
   |                      .-.: 
   |                     /|||\
   |                __.-'|||||'-.__
 --0------|------|------|------|-----------------> рост
   |            100    150    200
   |
     n чисел

=================================================================================
==-----------------------------------------------------------------------------==
==----------------  Введение в методы глобальной оптимизации  -----------------==
==-----------------------------------------------------------------------------==
=================================================================================


 ^
 |
 |                                  
 |                           .......'''''
 |\               .----''''''
 | \       .-.   /
 |  \     /   \ /
 |   \   /     '
 |    '-'      - local min  
 |     - global min
 |
-|--------------------------------------->
 |

   find local min's with ternar search and choose the global minimun


 ^  
 |
 |                                   
 |
 |
 |
 |
 |---------. .--------- ---------------
 |         |/          .
 |
 |
-|--------------------------------------->
 |

 ternar search doent work here, only 'for'

  Пример лотерея:

 ^ win
 |
 |                                   
 |
 |
 |                            .
 |   .
 |            
 |           .
 |--- ------- ---------------- -------
-|---------------------------------------> id
 |

 Монотонные ф-ии
 Битонные ф-ии из 2 мон. ф-ий


   ___   .--''''-
  /|_|| | БИТОН /_.
  |   \_\__/   \
  '(O) ---- (O)


 Тернарный поиск

 ^  
 |
 |                                   
 |
 |-.              .-
 |  |.         .-'   
 |  | \       /|     
 |  |  -     - |
 |  |   '-.-'  |    
 |  |          |
 | low        high
 |
-|--------------------------------------->
 |


известно, что:  min Е [low, high]

 ./  a = low + (high - low) / 3   = 2/3 * low + 1/3 * high
 '\  b = high - (high - low) / 3  = ...

base:
 if f[a] < f[b]
    min E [low, b]

 if f[a] > f[b]
     min E [a, high] 

 if f[a] == f[b]
     min E [a, b]    

 eps = 10e-9
 while high - low > eps
    ...base...
 ans = (low + high) / 2

 Каждая итерация: interval *= 2/3
 
 Другая версия (Фиббоначиев поиск):
  |----1----|--x--|----1----|
  |--1--|-x-|--1--|
 Сохранять отношение
 x^2 - x = 1
 / x^2 - x - 1 = 0
 \ x < 1
 x = (sqrt(5) - 1)/2 = phi^- 1

 за 2 итерации interval *= phi^-1
 ! Факт: отношение чисел фиббоначи с увеличением номеров стремится к фи



 ^  
 |
 |                                   
 |         a    b
 |         .----.
 |\        |    |        /\/\
 | \       |   .|       /    \
 |  \     .|  / \     _/
 |   \   / \ /   \_.-'
 |    '-'   '
 |
-|--------------------------------------->
 |

здесь терн. поиск не работает
n-арный поиск, разбить на n частей
low +- 100; high +- 100
и рекурсивно для каждого подинтервала

-------------------------------------------------------------------------------
                   однозвязные и двусвязные списки
-------------------------------------------------------------------------------
from collections import deque

2 3 9 5 6 6


head = [5, first6]
first6 = [6, last6]
last6 = [6, None]

empty = None


head == [5, [6, [6, None]]]


def length(node):
    if node:
        return 1 + length(node[1])
    return 0

def sumn(node):
    if node:
        return node[0] + length(node[1])
    return 0

def elementAt(node, index):
    if not node:
        return None
    if not index:
        return node[0]
    return elementAt(node[1], index - 1)

def delete(node): #deletes next el after node
    node[1] = node[1][1]

def insert(node, x):
    node[1] = [x, node[1]]

--------------------------------------------------------
                  Двусвязные списки
--------------------------------------------------------

      v  next  prev      
el = [5, None, None]
 _________________________________________
 |                                       |
 |             5      6      6    None   |
 |   None<-----|<-----|<-----|<----|<----|
 ----None      |----->|----->|---->|-.
      ^______________________________|

def length(node)
    ...

def elementAt(node, n):
    ...

def delete(node): #deletes THIS node
    node[2][1] = node[1]
    node[1][2] = node[2]

def insert(node, x):
    a = [x, node[1], node]
    node[1] = a
    node[1][1][2] = a

### --- Кусок в тетрадке (Полиномиальные хэши, Алг. Кнута-Морриса-Пратта, Регэкспы) --- ###

############################################################################################
#                                                                                          #
#                       K   K     OOO     TTTTT    L       II   NN   N                     #
#                       K  K     O   O      T      L       II   N N  N                     #
#                       KKK      O   O      T      L       II   N  N N                     #
#                       K  K     O   O      T      L       II   N   NN                     #
#                       K   K     OOO       T      LLLLL   II   N    N                     #
#                                                                                          #
############################################################################################
Спасибо Дворкину:)
############################################################################################

* Kotlin интероперабельный с Java

|Kotlin -- "очень кроссплатформенный"
|-> JVM - Java Virtual Machine
|-> JS - JavaScript
|-> Kotlin Native

fun main() { println("Hello world!") }

------------------------  Базовые типы данных
Целочисленные типы:
    - Byte   1 байт
    - Short  2 байта
    ! Int    4 байта
    - Long   8 байт
    * BigInteger
Вещественные:
    - Float    4 байт
    ! Double   8 байт
    * BigDecimal
    ~ Символьные вычисления
Логические типы:
    ! Boolean (true / false)    1 байт
    * BitSet
Строковые типы:
    ! Char      2 байта
    ! String
Знаковые целочисленные типы:
    | Беззнаковый тип:
    |    //unsigned byte
       |Signed
       |____|____|____|____|____|____|____|____|
       |-128|  64|  32|  16|   8|   4|   2|   1|
       
 ___________________________________________________
 | Хранение вещественных чисел в памяти компьютера |
   Standart: IEEE 754      [i triple e]
   |-> decimal 32
   |   decimal 64
   |   decimal 128
   |-> binary 16
   |   binary 32    float
   |   binary 64    double  _____.
   |   binary 128                 |
   |   binary 256                 |
                                  |
                          _______/
                         /
                        V
=====-------------  DOUBLE:  -------------=====
                  [Binary 64]

 s            e                       m
|__$__|__|_......._|__|__$__|__|__|__|__|_..._|__|
   $                     $                       |
 ^ $ 11 bits (exponent)  $ 52 bits (mantissa)    |
 |
  \ bit 1 -> {0: "+", 1: "-"}


Научная нотация
+- ________ * 10 ^ экспонента (целая)
   мантисса ( полуинтервал [1, 10) )
   
Real Binary:

Но 0 не поддерживается

Сравнение: снача сравнение экспонент, если они равны то сравнение уже мантисс
e ∈ [0, 2047] /\ N

                m (52b)
(-1 ^ s) * 1. .......... * 2 ^ (e - 1023)    ---- нормальные числа в двоичной нотации

1.5 = (-1 ^ 0) * ( (((1))) + 2 ^ -1) * 2 ^ 0
-7 = -1.75 * 2 ^ 2 -->  1_00100000000_  (((1.)))1100000...     

e ∈ [1, 2046]             -- нормальные числа
e = 0                     -- субнормальные
e = 2047                  -- Nan & +-Infinity

   Субнормальные числа:
+1 ...  * 2 ^ 0

0               1 ||||||||||||||  2
                   2 ^ 52 номера (арифметическая прогрессия (шаг 2 ^ -52))
              
   (-1) ^ s * 2 ^ -1022 * 0. ...
                 

m = 0   -> inf (+-)
m =/= 0 -> NaN


min normal: 2 ^ -1074
max normal: 2 ^ 1075


if (cond) {
    ...
    ret;
} else if (cond2) {
    ...
    ret2;
} else {
    ...
    ret3;
}

for (val in coll) {
    
}

val n = 10
for (x in n - 3 .. n + 5) { println(x) }
for (x in 1..10) { prinln(x) }

run {
    val x = 7
    println(x)
}


Ranges (IntRange)

for (x in 0 until 10)
for (x in 10 downTo 0)

for (x in 0 until 5 step 2) { ... }  // for (int x = 0; x < 5; x += 2) { ... }    for x in range(1, 5, 2):
for (x in 10 downTo 0 step 3) { ... }  // for (int x = 10; x >= 0; x -= 3) { ... }    for x in range(10, -1, -3):


cycle@for (...) {
    for (...) {
        if (...) {
            break@cycle
        }
    }
}

Функции:

fun name(Param: Type): RetType { // Default RetType = Unit [void]
    return ...
}

fun name(Param: Type) = return ...



Коллекции:

- Списки (Изменяемые и неизменяемые) (как списки и кортежи в питоне)

List        <--> tuple
MutableList <--> list

val a = listOf(2, 3, 9)
val b = listOf<Any>()

val a = mutableListOf(2, 3, 9)
val b = mutableListOf<Any>()

val x = a[i];
val first = a.first()
val last = a.last()
val size = a.size

"Умное создание списка" like [x for x in range(4, 5 * n - 1, 3)]
 List((5 * n - 1) / 3) { (it + 4) * 3 }

val a = List(100) { 0 }

Формально:
val b = List(length) {
    ...any code...
    returnValue
}

var x = 1.toBigInteger
val a = List(100) { 
    x *= 2.toBigInteger
    x
}


val a = List(100) { it } // it - position

repeat(100) { println(it) }

val a = List(100) { i ->  // now it is i
    println(i)
    i + 1
}

val tb = List(4) { i ->
    List(4) { j -> (i + 1) * (j + 1) }
}


a.take(7) // first 7 elements
a.takeLast(7) // last 7 elements

a.shuffled().take(7) // random 7 elements


#####################################
## Хвостовая рекурсия
Оптимизирвать - tailrec

factorial(n) -> factorial(n, acc)
 
fun fact1(n: Int): Int { // no tailrec
    if (n < 2) return 1
    return n * fact1(n - 1)
}

fun fact2(n: Int, acc: Int = 1) { // tailrec
    if (n < 2) return acc
    return fact2(n - 1, acc * n)
}

########################################
## Перестановки (получение следующей или предыдущей лексикографической перестановки)

Комбинаторные объекты:
     перестановки (n и массив длины n с числами от 1 до n
     строки с числами от 0 до k

] перестановки:
     1 2 3
     1 3 2
     2 1 3
     2 3 1
     3 1 2
     3 2 1
     


4 2 5 7 6 3 1
4 2 6 1 3 5 7
    ^
    | самая последняя позиция возрастания
      заменяем на минимаальное число > 5 (меняем местами)
      все, что правее сортируем в возрастающем порядке (можно развернуть
          так как они были в предыдущей подперестановке (последней) 
          развернуты в убывающем порядке)

генерация i-ой перестановки
(количество объектов меньше текущего)


===============================================================================
======================== ДИНАМИЧЕСКОЕ ПРОГРАММИРОВАНИЕ ========================
===============================================================================
  
- Задача о кузнечике
  
  
   V V X V V X V V
  |_|_|_|_|_|_|_|_|
   0 1 2 3 4 5 6 7
  
  ok = [1, 1, 0, 1, 1, 0, 1, 1]
  
  Кузнечик может прыгять вправо на 1, 2 или 3 клетки
  Сколько способов попасть в кллетку i: dp[i]
  
  в i можно попасть из i - 1 (если ok[i - 1]), i - 2 (если ok[i - 2]), i - 3 (если ok[i - 3])
  число вариантов dp[i] = (dp[i - 1] * ok[i - 1]) + (dp[i - 2] * ok[i - 2]) + (dp[i - 3] * ok[i - 3])
  
- Задача о черепахе
    черепаха ходит на (0; 1), (1; 0), (1, 1)
    в каждый клетке лежат очки, и есть запрещенные клетки

    tab: [
         [  0   2  -8  ]
         [ -1   5   4  ]
         [  1  INF  8  ]
    ]
        tab переобразовать в:
    tab: [
         [ -INF -INF -INF -INF ]
         [ -INF   0    2   -8  ]
         [ -INF  -1    5    4  ]
         [ -INF   1  -INF   8  ]
    ]
       
    dp[i][j] - лучший путь из [0][0] -> [i][j]
    
    dp = array (n + 1) { array(m + 1) }

    for i in 1..n
        for j in 1..m
            if tab[i][j] == -INF then
                dp[i][j] = -INF
                continue
            
            dp[i][j] = tab[i][j] + max(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1])
            
            prev[i][j] = {i - 1, j}
            if dp[i][j - 1] > dp[i - 1][j] then 
                prev[i][j] = {i, j - 1}
            if dp[i - 1][j - 1] > dp[i][j - 1] then
                prev[i][j] = {i - 1, j - 1}

################################################################################
################################## Теория игр ##################################
################################################################################
 * Игра для двух игроков на ациклических графах
 * Игра с нулевой суммой (константной: к очкам можно добавить -c/n, n - число игроков, c = sum = const)
 * Пошаговая
 * С полной информацией
 
 :
    - Положение на поле
    - Куда можно ходить
    - Кто не может сделать ход проиграл
 
   |---.v.--.v.------v
   .    .    .   .   .
   |_________^___^___^
   
   0) Если из позиции нет ребер (в другую позицию) -> проигрыш
      0.1) Есть выигрышная позиция (в которой существует выигрышная стратегия)
   1) Существует ребро ведущее в проигрышную позицию
   
           .----> 
          x------> Есть ребро в проигрышную позицию (П) <=> выигрыш (В)
           .----> 
           
          
          2) Все ребра в В => текущая позиция - П    | все правила эквивалентны этому
          
          Расставлять точки в порядке обратном топологической сортировке
          
          dp...
          
          dp = arr<bool> (n) 
          заполнить по правилу (2)
          
          
          
###############################################################################
* Ассимитричное шифрование (Алгоритм Меркла-Хэллмана) (хорошая статья на вики)
* Задача о рюкзаке (На neerc)
###############################################################################


################## Основы информатики #####################
    Понятние алгоритма и машина Тьюринга
 
###### Тьюринг-Полнота / Тьюринг полны ебъекты ######

f: X->Y  -- математическая функция

можно вычислить в системе A => В системе В тоже можно вчислить

Почему ни один язык программирование не выразителнее другого?
Kotlin >= Python, Python >= Kotlin
На Kotlin можно эмулировать Python
На Python можно эмулировать Kotlin


############################## Машина Тьюринга ##############################

Лента 

 Конечный Алфавит (здесь 01) 
 
 ._._._._._._._._._._._._._._._.
 |_|_|_|0|1|1|1|0|1|1|1|_|_|_|_|


Конечное множество состояний у каждой клетки

Пример
 (q2, 1) -> (q3, 0, <-/->)
 
 Состояние, буква -> Состояние, буква, сдвиг
 
Проверка на четность

q0, 0     q1, _, ->
...


################################# P =?= NP #################################

P - Polinomial, NP - Nondeterministic polinomial

Класс задач P  - Yes/No задачи, которые разрешимы на                     машине тьюринга за полиномиальное время
Класс задач NP - Yes/No задачи, которые разрешимы на недетерминированной машине тьюринга за полиномиальное время

Недетерминированная машина Тьюринга (квантовый компьютер) - 

 ._._._._._._._._._._._._._._._.
 |_|_|_|0|1|1|1|0|1|1|1|_|_|_|_|
        ^

                  b4    
Детер.:      q19      -> (q14, b5, <-)

                  b4    
Недетер.:    q19      -> (q14, b5, <-)
                      -> (q10, b5, ->)
                      -> ...
                      ...
                      
  
НМТ выдаёт ответ YES когда существует путь из текущего состояния в состояние в котором ответ YES
Для судоку (любой задаче на графах)
Реальный ответ NO - Ответ YES точно не возникнет (идет по какому-то пути)
Реальный ответ YES - вознможно будет YES


