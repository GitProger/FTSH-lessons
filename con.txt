Корзинная сортировка
 Busket Sort

 Данные: равномерно распределенные вещественные числа [0; 1)
   сигма - среднее квад. двух границ(y), характеризует насколько "колокольчик" "растянут"

   ^ y
   |
   |           .''.  .sg.
   |          /    \ :  :
   |        .'      ':  :
   |  __..-"          "-:.__
 --0--------------------------> x
   |

 n - длина массива
 поделим отрезок на n одинаковых корзин
 [0; 1/n) [1/n; 2/n) ... [(n-1)/n; 1)
 x - число, номер его корзины int(x * n)

 --- Листинг -----------------------------
   def busket_sort(a: list, n: int):
       bus = [[] for _ in range(n)]
       for x in a:
           b = int(x * m)
           bus[b].append(x)
       res = []
       for i in range(n):
           res += sorted(bus[i])
       return res
 -----------------------------------------

  Если не равномерно распределены числа, то работа - работа sorted (или любой другой сортировки)

 Сложность:
    n чисел раскиданы по корзинам
    запустим сортировку пузырьком без оптимизации на каждой группе
    m(m - 1) / 2
    C{m, 2}
    каждая пара чисел в одной корзине ==> 1 операция
    теперь оценить мат. ожидание кол-ва таких пар
    сумму этих велечин
    
    оценить кол-во пар в каждой корзине (1 пара - такт)
    Время: Итого кол-во пар попавших в одну корзину =
    = (кол-во пар чисел) * (на вероятность попасть пары в одну корзину)
    всего n(n - 1) / 2 пар чисел

    для каждой пары с какой веротностью они попадают в корзину: 1/n

    всего n^2 вариантов расположения из них в одну корзину - n вариантов
    итого n

    O' = (n(n - 1) / 2) * (1 / n) = (n - 1) / 2 ~= n
    O(n)


   ^ число людей
   |
   |
   |
   |                         доля чисел в этом диапазоне 1 / n - Квантель
   |                      .-.: 
   |                     /|||\
   |                __.-'|||||'-.__
 --0------|------|------|------|-----------------> рост
   |            100    150    200
   |
     n чисел

=================================================================================
==-----------------------------------------------------------------------------==
==----------------  Введение в методы глобальной оптимизации  -----------------==
==-----------------------------------------------------------------------------==
=================================================================================


 ^
 |
 |                                  
 |                           .......'''''
 |\               .----''''''
 | \       .-.   /
 |  \     /   \ /
 |   \   /     '
 |    '-'      - local min  
 |     - global min
 |
-|--------------------------------------->
 |

   find local min's with ternar search and choose the global minimun


 ^  
 |
 |                                   
 |
 |
 |
 |
 |---------. .--------- ---------------
 |         |/          .
 |
 |
-|--------------------------------------->
 |

 ternar search doent work here, only 'for'

  Пример лотерея:

 ^ win
 |
 |                                   
 |
 |
 |                            .
 |   .
 |            
 |           .
 |--- ------- ---------------- -------
-|---------------------------------------> id
 |

 Монотонные ф-ии
 Битонные ф-ии из 2 мон. ф-ий


   ___   .--''''-
  /|_|| | БИТОН /_.
  |   \_\__/   \
  '(O) ---- (O)


 Тернарный поиск

 ^  
 |
 |                                   
 |
 |-.              .-
 |  |.         .-'   
 |  | \       /|     
 |  |  -     - |
 |  |   '-.-'  |    
 |  |          |
 | low        high
 |
-|--------------------------------------->
 |


известно, что:  min Е [low, high]

 ./  a = low + (high - low) / 3   = 2/3 * low + 1/3 * high
 '\  b = high - (high - low) / 3  = ...

base:
 if f[a] < f[b]
    min E [low, b]

 if f[a] > f[b]
     min E [a, high] 

 if f[a] == f[b]
     min E [a, b]    

 eps = 10e-9
 while high - low > eps
    ...base...
 ans = (low + high) / 2

 Каждая итерация: interval *= 2/3
 
 Другая версия (Фиббоначиев поиск):
  |----1----|--x--|----1----|
  |--1--|-x-|--1--|
 Сохранять отношение
 x^2 - x = 1
 / x^2 - x - 1 = 0
 \ x < 1
 x = (sqrt(5) - 1)/2 = phi^- 1

 за 2 итерации interval *= phi^-1
 ! Факт: отношение чисел фиббоначи с увеличением номеров стремится к фи



 ^  
 |
 |                                   
 |         a    b
 |         .----.
 |\        |    |        /\/\
 | \       |   .|       /    \
 |  \     .|  / \     _/
 |   \   / \ /   \_.-'
 |    '-'   '
 |
-|--------------------------------------->
 |

здесь терн. поиск не работает
n-арный поиск, разбить на n частей
low +- 100; high +- 100
и рекурсивно для каждого подинтервала

-------------------------------------------------------------------------------
                   однозвязные и двусвязные списки
-------------------------------------------------------------------------------
from collections import deque

2 3 9 5 6 6


head = [5, first6]
first6 = [6, last6]
last6 = [6, None]

empty = None


head == [5, [6, [6, None]]]


def length(node):
    if node:
        return 1 + length(node[1])
    return 0

def sumn(node):
    if node:
        return node[0] + length(node[1])
    return 0

def elementAt(node, index):
    if not node:
        return None
    if not index:
        return node[0]
    return elementAt(node[1], index - 1)

def delete(node): #deletes next el after node
    node[1] = node[1][1]

def insert(node, x):
    node[1] = [x, node[1]]

P.S. ужасный код
--------------------------------------------------------
                  Двусвязные списки
--------------------------------------------------------
Да блин!..

      v  next  prev      
el = [5, None, None]
 _________________________________________
 |                                       |
 |             5      6      6    None   |
 |   None<-----|<-----|<-----|<----|<----|
 ----None      |----->|----->|---->|-.
      ^______________________________|

def length(node)
    ...

def elementAt(node, n):
    ...

def delete(node): #deletes THIS node
    node[2][1] = node[1]
    node[1][2] = node[2]

def insert(node, x):
    a = [x, node[1], node]
    node[1] = a
    node[1][1][2] = a





